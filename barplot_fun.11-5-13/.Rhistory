col = c("lightblue", "mistyrose", "lightcyan",
"lavender", "cornsilk"),
legend = rownames(VADeaths), ylim = c(0, 100))
title(main = "Death Rates in Virginia", font.main = 4)
my_n = 5 # number of categories (taxa or functions) to plot
my_stats.summary.ordered.subset <- my_stats.summary.ordered[1:my_n,]
my_stats.summary.ordered.subset
num_profiles <- length(grep("group_mean", my_stats.summary.ordered.subset))
num_profiles
grep("group_mean", colnames(my_stats.summary.ordered.subset))
profile_indices <- grep("group_mean", colnames(my_stats.summary.ordered.subset))
profile_indices[1]
profile_indices[3]
my_data.color <- length(profile_indices)
my_data.color
my_data.color <- col.wheel(length(profile_indices))
my_data.color
as.list(profile_indices)
as.numeric(profile_indices)
profile_indices <- as.numeric(grep("group_mean", colnames(my_stats.summary.ordered.subset)))
my_data.color <- col.wheel(length(profile_indices))
my_data.color
barplot(  my_stats.summary.ordered.subset[,profile_indices], beside=TRUE, col=my_data.color,  legend=rownames(my_stats.summary.ordered.subset)      )
?barplot
my_stats.summary.ordered.subset[,profile_indices]
class(my_stats.summary.ordered.subset[,profile_indices])
my_stats.summary.ordered.subset <- as.matrix(my_stats.summary.ordered[1:my_n,])
profile_indices <- as.numeric(grep("group_mean", colnames(my_stats.summary.ordered.subset)))
my_data.color <- col.wheel(length(profile_indices))
barplot(  my_stats.summary.ordered.subset[,profile_indices], beside=TRUE, col=my_data.color,  legend=rownames(my_stats.summary.ordered.subset)      )
my_n = 5
# create a subselection of the data above
my_stats.summary.ordered.subset <- as.matrix(my_stats.summary.ordered[1:my_n,])
profile_indices <- as.numeric(grep("group_mean", colnames(my_stats.summary.ordered.subset)))
my_data.color <- col.wheel(length(my_n))
barplot(
my_stats.summary.ordered.subset[,profile_indices],
beside=TRUE,
col=my_data.color,
legend=rownames(my_stats.summary.ordered.subset)
)
my_stats.summary.ordered.subset <- as.matrix(my_stats.summary.ordered[1:my_n,])
profile_indices <- as.numeric(grep("group_mean", colnames(my_stats.summary.ordered.subset)))
my_data.color <- col.wheel(my_n)
barplot(
my_stats.summary.ordered.subset[,profile_indices],
beside=TRUE,
col=my_data.color,
legend=rownames(my_stats.summary.ordered.subset)
)
<- length(grep("group_mean", my_stats.summary.ordered.subset))
for (i in 1:dim(my_stats.summary.ordered.subset)[2]){
barplot(
my_stats.summary.ordered.subset[,profile_indices],
beside=TRUE,
col=my_data.color,
legend=rownames(my_stats.summary.ordered.subset),
args.legend = list(x="topleft")
)
)
barplot(
my_stats.summary.ordered.subset[,profile_indices],
beside=TRUE,
col=my_data.color,
legend=rownames(my_stats.summary.ordered.subset),
args.legend = list(x="topleft")
)
par(xpd = TRUE)
l <- locator(1)
par(xpd = TRUE)
barplot(
my_stats.summary.ordered.subset[,profile_indices],
beside=TRUE,
col=my_data.color,
legend=rownames(my_stats.summary.ordered.subset),
args.legend = list(x=-1)
)
barplot(
my_stats.summary.ordered.subset[,profile_indices],
beside=TRUE,
col=my_data.color,
legend=rownames(my_stats.summary.ordered.subset),
args.legend = list(x=c(1,2)
)
)
profile_indices
library(matlab)
barplot(VADeaths, beside = TRUE,
col = c("lightblue", "mistyrose", "lightcyan",
"lavender", "cornsilk"),
legend = rownames(VADeaths), ylim = c(0, 100))
title(main = "Death Rates in Virginia", font.main = 4)
my_stats.summary.ordered.subset.rot_90 <- rot90(  my_stats.summary.ordered.subset[,profile_indices]  )
my_stats.summary.ordered.subset.rot_90
my_n = 5
# create a subselection of the data above
my_stats.summary.ordered.subset <- as.matrix(my_stats.summary.ordered[1:my_n,])
profile_indices <- as.numeric(grep("group_mean", colnames(my_stats.summary.ordered.subset)))
# Rotate the subselected data so its suitable for the barplot function
my_stats.summary.ordered.subset.rot_90 <- rot90(  my_stats.summary.ordered.subset[,profile_indices]  )
# Genrate colors based on the number of groups
my_data.color <- col.wheel(num_groups)
#par(xpd = TRUE)
#l <- locator(1)
barplot(
my_stats.summary.ordered.subset.rot_90,
beside=TRUE,
col=my_data.color,
legend=rownames(my_stats.summary.ordered.subset.rot_90)
#args.legend = list(x=c(1,2))
)
my_stats.statistic
my_stats.fdr
par(xpd = TRUE)
barplot(
my_stats.summary.ordered.subset.rot_90,
beside=TRUE,
col=my_data.color,
legend=rownames(my_stats.summary.ordered.subset.rot_90)
args.legend = list(x=1)
)
barplot(
my_stats.summary.ordered.subset.rot_90,
beside=TRUE,
col=my_data.color,
legend=rownames(my_stats.summary.ordered.subset.rot_90)
args.legend = list(x=1)
)
barplot(
my_stats.summary.ordered.subset.rot_90,
beside=TRUE,
col=my_data.color,
legend=rownames(my_stats.summary.ordered.subset.rot_90),
args.legend = list(x=1)
)
barplot(
my_stats.summary.ordered.subset.rot_90,
beside=TRUE,
col=my_data.color,
legend=rownames(my_stats.summary.ordered.subset.rot_90),
args.legend = list(x=1.5)
)
?legend
barplot(
my_stats.summary.ordered.subset.rot_90,
beside=TRUE,
col=my_data.color,
legend=rownames(my_stats.summary.ordered.subset.rot_90),
args.legend = list(x="topleft")
#args.legend = list(x=1.5)
)
legend
?legend
library(ggplot)
library(ggplot2)
ggplot(
my_stats.summary.ordered.subset.rot_90,
beside=TRUE,
col=my_data.color,
legend=rownames(my_stats.summary.ordered.subset.rot_90),
args.legend = list(x="topleft")
)
my_matrix <-  data.matrix(read.table("my_file", row.names=1, header=TRUE, check.names=FALSE, sep="\t", comment.char="", quote=""))
num_breaks <- 1000
num_values <- length(my_matrix)
my_hist <- hist(my_matrix, breaks = num_breaks)
my_colors = rainbow(num_breaks)
n_row <- dim(my_matrix)[1]
n_col <- dim(my_matrix)[2]
#my_color_matrix <- matrix("", n_row, n_col)
my_color_vector <- character(length=num_breaks)
for (r in 1:n_row){
for ( c in 1:n_col){
for ( k in 1:num_breaks){
if ( my_matrix[r,c] >= my_hist$breaks[k] ) { my_color_vector[k] <- my_colors[k] }
}
}
}
image(my_matrix, col = my_color_vector)
my_matrix <- data.matrix(read.table("my_file", row.names=1, header=TRUE, check.names=FALSE, sep="\t", comment.char="", quote=""))
num_breaks <- 1000
num_values <- length(my_matrix)
my_hist <- hist(my_matrix, breaks = num_breaks)
my_colors = rainbow(num_breaks)
n_row <- dim(my_matrix)[1]
n_col <- dim(my_matrix)[2]
#my_color_matrix <- matrix("", n_row, n_col)
my_color_vector <- character(length=num_breaks)
for (r in 1:n_row){
for ( c in 1:n_col){
for ( k in 1:num_breaks){
if ( my_matrix[r,c] >= my_hist$breaks[k] ) { my_color_vector[k] <- my_colors[k] }
}
}
}
image(my_matrix, col = my_color_vector)
num_breaks <- 1000
my_colors = rainbow(num_breaks)
my_colors
my_colors = rainbow(1000)
image(matrix(1:1000, 10), col = my_colors)
my_colors = rainbow(100)
image(matrix(1:1000, 10), col = my_colors)
my_colors = rainbow(100)
image(matrix(1:100, 10), col = my_colors)
layout(matrix(c(1,2),nrow=1), widths=c(2,1))
split.screen(2,1)
screen(1)
image(matrix(1:100, 10), col = my_colors)
split.screen(2,1)
screen(1)
layout(matrix(c(1,2),nrow=1), widths=c(2,1))
image(matrix(1:100, 10), col = my_colors)
?layout
def.par <- par(no.readonly = TRUE) # save default, for resetting...
## divide the device into two rows and two columns
## allocate figure 1 all of row 1
## allocate figure 2 the intersection of column 2 and row 2
layout(matrix(c(1,1,0,2), 2, 2, byrow = TRUE))
## show the regions that have been allocated to each plot
layout.show(2)
layout.show()
layout.show(3)
layout.show(1)
layout.show(2)
layout.show(3)
layout.show(2)
?layout
## divide device into two rows and two columns
## allocate figure 1 and figure 2 as above
## respect relations between widths and heights
nf <- layout(matrix(c(1,1,0,2), 2, 2, byrow=TRUE), respect=TRUE)
layout.show(nf)
?layout
x <- pmin(3, pmax(-3, stats::rnorm(50)))
y <- pmin(3, pmax(-3, stats::rnorm(50)))
xhist <- hist(x, breaks=seq(-3,3,0.5), plot=FALSE)
yhist <- hist(y, breaks=seq(-3,3,0.5), plot=FALSE)
top <- max(c(xhist$counts, yhist$counts))
xrange <- c(-3,3)
yrange <- c(-3,3)
nf <- layout(matrix(c(2,0,1,3),2,2,byrow=TRUE), c(3,1), c(1,3), TRUE)
layout.show(nf)
par(mar=c(3,3,1,1))
plot(x, y, xlim=xrange, ylim=yrange, xlab="", ylab="")
par(mar=c(0,3,1,1))
barplot(xhist$counts, axes=FALSE, ylim=c(0, top), space=0)
par(mar=c(3,0,1,1))
barplot(yhist$counts, axes=FALSE, xlim=c(0, top), space=0, horiz=TRUE)
par(def.par)#- reset to default
nf <- layout(matrix(1), widths=lcm(5), heights=lcm(5))
layout.show(nf)
?layout
matrix(c(1,1,0,2)
)
matrix(c(1,1,0,2), 2, 2, byrow = TRUE)
my_matrix <- matrix(c(1,1,0,2), 2, 2, byrow = TRUE)
my_matrix
rep(1, ncol(my_matrix))
ncol(my_matrix)
layout( matrix(1,1,2) )
layout.show
layout.show()
layout.show(2)
?layout
?pdf
# Make sure that matR is loaded
require(matR)
require(matlab)
# require(ggplot2)
############################################################################
# Color methods https://stat.ethz.ch/pipermail/r-help/2002-May/022037.html
############################################################################
# The inverse function to col2rgb()
col.wheel <- function(num_col, my_cex=0.75) {
cols <- rainbow(num_col)
col_names <- vector(mode="list", length=num_col)
for (i in 1:num_col){
col_names[i] <- getColorTable(cols[i])
}
# pie(rep(1, length(cols)), labels=col_names, col=cols, cex=my_cex) }
cols
}
# The inverse function to col2rgb()
rgb2col <- function(rgb) {
rgb <- as.integer(rgb)
class(rgb) <- "hexmode"
rgb <- as.character(rgb)
rgb <- matrix(rgb, nrow=3)
paste("#", apply(rgb, MARGIN=2, FUN=paste, collapse=""), sep="")
}
# Convert all colors into format "#rrggbb"
getColorTable <- function(col) {
rgb <- col2rgb(col);
col <- rgb2col(rgb);
sort(unique(col))
}
############################################################################
############################################################################
# stat tests from matR::sigtest, for pair then 3 or more
my_stats = "Kruskal-Wallis" # non normal data
# my_stats = "ANOVA-one-way" # paramtric   # normal data
# import data
file_name = "sample_data.1_2_are_group.txt"
my_data <- read.table(file_name, header=TRUE, stringsAsFactors=FALSE, sep="\t", comment.char="", quote="", check.names=FALSE, row.names=1 )
# get dimensions of the data
my_data.n_rows <- nrow(my_data)
my_data.n_cols <- ncol(my_data)
# get the sums and averages for all columns in the data
my_data.sum <- as.matrix(rowSums(my_data))
colnames(my_data.sum) <- "sum_all_samples"
my_data.mean <- as.matrix(rowMeans(my_data))
colnames(my_data.mean) <- "mean_all_samples"
# create a groups vector for the data
#my_groups <- c(rep(1,"group"), rep(2,"group"), rep(3,"group3"))
my_groups <- c(rep("group1", 2), rep("group2", 3), rep("group3", 4))
# name the groups vector with sample ids from the imported data
names(my_groups) <- colnames(my_data)
# factor the groups
my_groups.factor <- factor(my_groups)
# get the levels of the factors (get the list of unique groups)
my_groups.levels <- levels(factor(my_groups))
# get the number of groups
num_groups <- nlevels(my_groups.factor)
# sigtest to perform stats
# place selected stat in variable for use below
my_stat = "Kruskal-Wallis"
# perform stat tests (uses matR)
my_stats <- sigtest(my_data, my_groups, my_stat)
# Create headers for the data columns
for (i in 1:dim(my_data)[2]){ colnames(my_data)[i] <- paste( colnames(my_data)[i], "::", (my_groups)[i], sep="" )  }
for (i in 1:dim(my_stats$mean)[2]){ colnames(my_stats$mean)[i] <- paste( colnames(my_stats$mean)[i], "::group_mean", sep="" )  }
for (i in 1:dim(my_stats$sd)[2]){ colnames(my_stats$sd)[i] <- paste( colnames(my_stats$sd)[i], "::group_sd", sep="" )  }
my_stats.statistic <- as.matrix(my_stats$statistic)
colnames(my_stats.statistic) <- paste(my_stat, "::stat", sep="")
my_stats.p <- as.matrix(my_stats$p.value)
colnames(my_stats.p) <- paste(my_stat, "::p", sep="")
my_stats.fdr <- as.matrix(p.adjust(my_stats$p.value))
colnames(my_stats.fdr) <- paste(my_stat, "::fdr", sep="")
# generate a summary object - used to generate the plots, and can be used to create a flat file output
my_stats.summary <- cbind(my_data, my_data.mean, my_stats$mean, my_stats$sd, my_stats.statistic, my_stats.p, my_stats.fdr)
# selection column to order the data by
order_by = "mean_all_samples"
## or order by mean values in a single group
# order_by = paste("group1", "::group_mean", sep="")
## or order by FDR
# order_by = paste(my_stat, "::fdr", sep="")
# order the data by the selected column - placing ordered data in a new object
my_stats.summary.ordered <- my_stats.summary[ order(my_stats.summary[,order_by], decreasing=TRUE), ]
# flat file output of the summary file
write.table(my_stats.summary.ordered, file = "my_stats.summary.txt", col.names=NA, row.names = rownames(my_stats.summary), sep="\t", quote=FALSE)
# select number of categories (taxa or functions) to plot in the barplot
my_n = 5
# create a subselection of the data above based on selected number of categories
my_stats.summary.ordered.subset <- as.matrix(my_stats.summary.ordered[1:my_n,])
profile_indices <- as.numeric(grep("group_mean", colnames(my_stats.summary.ordered.subset)))
# Rotate the subselected data so its suitable for the barplot function
my_stats.summary.ordered.subset.rot_90 <- rot90(  my_stats.summary.ordered.subset[,profile_indices]  )
# Genrate colors based on the number of groups
my_data.color <- col.wheel(num_groups)
my_pdf = paste(file_name, ".barplot.pdf", sep="")
pdf ( file=my_pdf, width=8.5, height=4 )
plot.new()
split.screen(c(1,2))
screen(1)
legend=rownames(my_stats.summary.ordered.subset.rot_90)
screen(2)
barplot(
my_stats.summary.ordered.subset.rot_90,
beside=TRUE,
col=my_data.color,
)
dev.off()
getwd()
?legend
my_pdf = paste(file_name, ".barplot.pdf", sep="")
pdf ( file=my_pdf, width=8.5, height=4 )
#plot.new()
split.screen(c(1,2))
screen(1)
#legend=rownames(my_stats.summary.ordered.subset.rot_90)
legend( x="center", legend=rownames(my_stats.summary.ordered.subset.rot_90) )
screen(2)
barplot(
my_stats.summary.ordered.subset.rot_90,
beside=TRUE,
col=my_data.color,
)
dev.off()
my_pdf = paste(file_name, ".barplot.pdf", sep="")
pdf ( file=my_pdf, width=8.5, height=4 )
#plot.new()
split.screen(c(1,2))
screen(1)
#legend=rownames(my_stats.summary.ordered.subset.rot_90)
legend( x="center", legend=rownames(my_stats.summary.ordered.subset.rot_90), pch=15, col=my_data.color )
screen(2)
barplot(
my_stats.summary.ordered.subset.rot_90,
beside=TRUE,
col=my_data.color,
)
dev.off()
my_pdf = paste(file_name, ".barplot.pdf", sep="")
pdf ( file=my_pdf, width=8.5, height=4 )
#plot.new()
#split.screen(c(1,2))
split.screen(matrix(c(0,0.5,0,0.5,  0.5,1,0.5,1), byrow=T, ncol=4))
screen(1)
#legend=rownames(my_stats.summary.ordered.subset.rot_90)
legend( x="center", legend=rownames(my_stats.summary.ordered.subset.rot_90), pch=15, col=my_data.color )
screen(2)
barplot(
my_stats.summary.ordered.subset.rot_90,
beside=TRUE,
col=my_data.color,
las=2
)
dev.off()
matrix(c(0,0.5,0,0.5,  0.5,1,0.5,1), byrow=T, ncol=4)
my_pdf = paste(file_name, ".barplot.pdf", sep="")
pdf ( file=my_pdf, width=8.5, height=4 )
#plot.new()
#split.screen(c(1,2))
### from https://stat.ethz.ch/pipermail/r-help/2004-January/044285.html
### matrix(c(0,0.5,0,0.5,  0.5,1,0.5,1), byrow=F, ncol=4)
###[,1] [,2] [,3] [,4]
###[1,]  0.0  0.0  0.5  0.5
###[2,]  0.5  0.5  1.0  1.0
###      left right bot top
### so both your figures are 0 wide and 0 tall. How about
###matrix(c(0,0.5,0,0.5,  0.5,1,0.5,1), byrow=T, ncol=4)
###[,1] [,2] [,3] [,4]
###[1,]  0.0  0.5  0.0  0.5
###[2,]  0.5  1.0  0.5  1.0
###      left right bot top
split.screen(matrix(c(1,1,1,1,  1,1,1,1), byrow=T, ncol=4))
#split.screen(matrix(c(0,0.5,0,0.5,  0.5,1,0.5,1), byrow=T, ncol=4))
screen(1)
#legend=rownames(my_stats.summary.ordered.subset.rot_90)
legend( x="center", legend=rownames(my_stats.summary.ordered.subset.rot_90), pch=15, col=my_data.color )
screen(2)
barplot(
my_stats.summary.ordered.subset.rot_90,
beside=TRUE,
col=my_data.color,
las=2
)
dev.off()
?read.lines
?read.line
?scan
?readLines
dir()
getwd()
dir()
getwd()
setwd("~/git/matR-apps.DrOppenheimer/matR-apps/barplot_fun.11-5-13/barplot_tool.11-5-13.r")
source("~/git/matR-apps.DrOppenheimer/matR-apps/barplot_fun.11-5-13/barplot_tool.11-5-13.r")
barplot_tool
barplot_tool()
dir()
getwd()
dir()
getwd()
setwd("/Users/kevin/git/matR-apps.DrOppenheimer/matR-apps/barplot_fun.11-5-13")
source("~/git/matR-apps.DrOppenheimer/matR-apps/barplot_fun.11-5-13/barplot_tool.11-5-13.r")
barplot_tool()
source("~/git/matR-apps.DrOppenheimer/matR-apps/barplot_fun.11-5-13/barplot_tool.11-5-13.r")
barplot_tool()
source("~/git/matR-apps.DrOppenheimer/matR-apps/barplot_fun.11-5-13/barplot_tool.11-5-13.r")
barplot_tool()
plot(x="")
plot(x=" ")
?plot
plot(x,y, main="test")
source("~/git/matR-apps.DrOppenheimer/matR-apps/barplot_fun.11-5-13/barplot_tool.11-5-13.r")
barplot_tool()
source("~/git/matR-apps.DrOppenheimer/matR-apps/barplot_fun.11-5-13/barplot_tool.11-5-13.r")
barplot_tool()
source("~/git/matR-apps.DrOppenheimer/matR-apps/barplot_fun.11-5-13/barplot_tool.11-5-13.r")
source("~/git/matR-apps.DrOppenheimer/matR-apps/barplot_fun.11-5-13/barplot_tool.11-5-13.r")
barplot_tool()
?plot.new()
?frame
?par
plot("test")
?text
source("~/git/matR-apps.DrOppenheimer/matR-apps/barplot_fun.11-5-13/barplot_tool.11-5-13.r")
barplot_tool()
source("~/git/matR-apps.DrOppenheimer/matR-apps/barplot_fun.11-5-13/barplot_tool.11-5-13.r")
barplot_tool()
source("~/git/matR-apps.DrOppenheimer/matR-apps/barplot_fun.11-5-13/barplot_tool.11-5-13.r")
barplot_tool()
source("~/git/matR-apps.DrOppenheimer/matR-apps/barplot_fun.11-5-13/barplot_tool.11-5-13.r")
barplot_tool()
source("~/git/matR-apps.DrOppenheimer/matR-apps/barplot_fun.11-5-13/barplot_tool.11-5-13.r")
barplot_tool()
source("~/git/matR-apps.DrOppenheimer/matR-apps/barplot_fun.11-5-13/barplot_tool.11-5-13.r")
barplot_tool()
source("~/git/matR-apps.DrOppenheimer/matR-apps/barplot_fun.11-5-13/barplot_tool.11-5-13.r")
barplot_tool()
barplot_tool()
source("~/git/matR-apps.DrOppenheimer/matR-apps/barplot_fun.11-5-13/barplot_tool.11-5-13.r")
barplot_tool()
source("~/git/matR-apps.DrOppenheimer/matR-apps/barplot_fun.11-5-13/barplot_tool.11-5-13.r")
barplot_tool()
source("~/git/matR-apps.DrOppenheimer/matR-apps/barplot_fun.11-5-13/barplot_tool.11-5-13.r")
barplot_tool()
source("~/git/matR-apps.DrOppenheimer/matR-apps/barplot_fun.11-5-13/barplot_tool.11-5-13.r")
barplot_tool()
?barplot
